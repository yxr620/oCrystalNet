import random
import math
import numpy as np

from argparse import Namespace
from typing import Callable, List, Union
from pymatgen.analysis.local_env import VoronoiNN
from torch.utils.data.dataset import Dataset
from pymatgen.io.vasp import Poscar
from pymatgen.core import Structure


def make_hot_for_atom_i(crystal, i, hvs):

    EP = str(crystal[i].specie)
    HV_P = np.nan_to_num(hvs[EP]) # the electrical presentation of EP
    # print(f"EP {type(EP)}")
    # print(f"HV_P {HV_P}")
    AA = HV_P.reshape((HV_P.shape[1], 32)) # change colume vector to row vector
    # print(f"AA {AA}")
    A = np.array(AA)
    # we need to increase the cut off to 14 to handle this problems
    b=VoronoiNN(cutoff=14).get_nn_info(crystal, i) # problems
    # print(f"b {b}")
    # print(f"len {len(b)}")
    angles = []
    for nb in b:
        angle_K = nb['poly_info']['solid_angle']
        angles.append(angle_K)
    max_angle = max(angles)
    X_P = np.zeros(shape=(32,32))
    tmp_X = []
    for nb in b:
        EK = str(nb['site'].specie)
        angle_K = nb['poly_info']['solid_angle']
        index_K = nb['site_index']
        r_pk = ((calculateDistance(nb['site'].coords, crystal[i].coords)) * (calculateDistance(nb['site'].coords,crystal[i].coords)))
        HV_K = hvs[EK]
        HV_K = HV_K.reshape((HV_K.shape[1], 32))
        coef_K = (angle_K/max_angle)*((1/((r_pk)**2)))
        HV_K_new= np.nan_to_num(coef_K * HV_K)
        X_PT = np.matmul(HV_P, HV_K_new)
        tmp_X.append(X_PT)
    X0 = np.zeros(shape=(32,32))
    for el in tmp_X:
        X0 = [[sum(x) for x in zip(el[i], X0[i])] for i in range(len(el))]
    X0  = np.concatenate((A.T,X0),axis = 1)
    X0 = np.asarray(X0)
    return X0 

def calculateDistance(a,b):   # Atom-wise OFM
    dist =math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2 + (a[2] - b[2])**2)
    return dist

class CrystalDatapoint:
    """A CrystalDatapoint contains a single crystal and its associated features and targets."""

    def __init__(self,
                 crystal_name: str = None,
                 crystal_dict: dict = None,
                 space_feature: List[float] = None,
                 targets: List[float] = None,
                 ari: object = None,
                 gdf: object = None,
                 radius_dic: dict = None,
                 hvs: dict = None,
                 args: Namespace = None
                 ):
        """
        Initializes a CrystalDatapoint, which contains a single crystal.

        # :param line: A list of strings generated by separating a line in a data CSV file by comma.
        # :param args: Arguments.
        # :param features: A numpy array containing additional features (ex. Morgan fingerprint).
        """

        self.name = crystal_name
        # we need some change here
        self.crystal = Structure.from_dict(crystal_dict)
        # self.crystal = Poscar.from_dict(crystal_dict).structure
        self.targets = targets


        # print(self.crystal)
        # construct atom features
        
        # print(self.crystal[0].specie)
        # exit(0)
        # print(len(self.crystal))
        # for i in range(len(self.crystal)):
        #     print(i)
        #     print(self.crystal[i])
        #     print(self.crystal[i].specie)
        # stack the atom init feature to a array. Add the space feature to each of the atom feature
        self.atom_features = np.vstack([ari.get_atom_features(self.crystal[i].specie.number) for i in range(len(self.crystal))])

        # we want to add another embedding here
        # print(f"crystal type {type(self.crystal)}")
        # b = VoronoiNN.get_all_nn_info(self.crystal)
        # print(f"len {len(b)}")

        # hot_fea = np.vstack([make_hot_for_atom_i(self.crystal,i,hvs).reshape(1, 1056) for i in range(len(self.crystal))])
        # self.atom_features = np.concatenate([self.atom_features, hot_fea], 1)
        # self.atom_features = np.vstack([make_hot_for_atom_i(self.crystal,i,hvs).reshape(1, 1056) for i in range(len(self.crystal))])

        # cat space_feature
        if space_feature != None:
            cat_feature = []
            for _ in range(np.shape(self.atom_features)[0]):
                cat_feature.append(space_feature)
            cat_feature = np.array(cat_feature)
            self.atom_features = np.concatenate([cat_feature, self.atom_features], 1)

        # construct bond features
        # (site, distance, index, image)
        all_neighbors = self.crystal.get_all_neighbors(r=args.radius, include_index=True)
        # sorted by distance
        all_neighbors = [sorted(neighbors, key=lambda x: x[1]) for neighbors in all_neighbors]

        point_indices, offset_vectors, distances = [], [], []

        for neighbors in all_neighbors:
            if len(neighbors) < args.max_num_neighbors:
                point_indices.append(list(map(lambda x: x[2], neighbors)) + [0] * (args.max_num_neighbors - len(neighbors)))
                offset_vectors.append(list(map(lambda x: list(x[3]), neighbors)) + [[0.0, 0.0, 0.0]] * (args.max_num_neighbors - len(neighbors)))
                distances.append(list(map(lambda x: x[1], neighbors)) + [args.radius + 1.] * (args.max_num_neighbors - len(neighbors)))
            else:
                point_indices.append(list(map(lambda x: x[2], neighbors[:args.max_num_neighbors])))
                offset_vectors.append(list(map(lambda x: list(x[3]), neighbors[:args.max_num_neighbors])))
                distances.append(list(map(lambda x: x[1], neighbors[:args.max_num_neighbors])))
        
        # print(f"get neighbor")
        # neighbors and their distance
        self.point_indices = np.array(point_indices) #atom_num * 8
        self.bond_features = gdf.expand(np.array(distances))

    def num_tasks(self) -> int:
        """
        Returns the number of prediction tasks.

        :return: The number of tasks.
        """
        return len(self.targets)

    def set_targets(self, targets: List[float]):
        """
        Sets the targets of a crystal.

        :param targets: A list of floats containing the targets.
        """
        self.targets = targets


class CrystalDataset(Dataset):
    """A CrystalDataset contains a list of crystals and their associated features and targets."""

    def __init__(self, data: List[CrystalDatapoint], args: Namespace = None):
        """
        Initializes a CrystalDataset, which contains a list of CrystalDatapoints (i.e. a list of crystals).

        :param data: A list of CrystalDatapoints.
        """
        self.data = data
        self.args = args
        self.scaler = None

    def names(self) -> List[str]:
        """
        Returns the crystal names associated with the crystal (if they exist).

        :return: A list of crystal names or None if the dataset does not contain crystal names.
        """
        if len(self.data) == 0 or self.data[0].name is None:
            return []
        else:
            return [d.name for d in self.data]

    def crystals(self) -> List[Poscar]:
        """
        Returns the structure associated with the crystal.

        :return: A list of Poscar crystal structures.
        """
        return [d.crystal for d in self.data]

    def targets(self) -> List[List[float]]:
        """
        Returns the targets associated with each crystal.

        :return: A list of lists of floats containing the targets.
        """
        return [d.targets for d in self.data]

    def num_tasks(self) -> int:
        """
        Returns the number of prediction tasks.

        :return: The number of tasks.
        """
        return self.data[0].num_tasks() if len(self.data) > 0 else None

    def shuffle(self, seed: int = None):
        """
        Shuffles the dataset.

        :param seed: Optional random seed.
        """
        if seed is not None:
            random.seed(seed)
        random.shuffle(self.data)

    def set_targets(self, targets: List[List[float]]):
        """
        Sets the targets for each crystal in the dataset. Assumes the targets are aligned with the datapoints.

        :param targets: A list of lists of floats containing targets for each crystal. This must be the
        same length as the underlying dataset.
        """
        assert len(self.data) == len(targets)
        for i in range(len(self.data)):
            self.data[i].set_targets(targets[i])

    def sort(self, key: Callable):
        """
        Sorts the dataset using the provided key.

        :param key: A function on a CrystalDatapoint to determine the sorting order.
        """
        self.data.sort(key=key)

    def __len__(self) -> int:
        """
        Returns the length of the dataset (i.e. the number of crystals).

        :return: The length of the dataset.
        """
        return len(self.data)

    def __getitem__(self, item) -> Union[CrystalDatapoint, List[CrystalDatapoint]]:
        """
        Gets one or more CrystalDatapoints via an index or slice.

        :param item: An index (int) or a slice object.
        :return: A CrystalDatapoint if an int is provided or a list of CrystalDatapoints if a slice is provided.
        """
        return self.data[item]
